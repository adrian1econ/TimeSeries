---
title: "Simulationsstudie"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulationsstudie}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Periodogramm
Das Periodogramm einer Zeitreihe $\{x_1,...,x_n\}$ ist eine stichprobenbasierte Funktion, aus der ein nicht-konsistenter Schätzer für die spektrale Leistungsdichtedichte gewonnen werden kann.
Das Periodogramm einer Zeitreihe $\{x_1,...,x_n\}$ ist definiert als:
$$
I_n(\lambda)=n^{-1} \Bigg| \sum \limits_{t=1}^{n}x_{t}e^{-it\lambda} \Bigg| ^2
$$

Das Periodogramm folgt der Idee ein Signal in sinusartige Funktionen mit unkorrelierten Koeffizienten zu zerlegen. 
$$
x_t=\sum \limits_{j \in F_n}a_j [\cos(\omega_jt) + i \sin(\omega_jt)]
$$
mit$\omega_j = 2 \pi j$, den Fourier Frequenzen der Zeitreihe $\{x_1,...,x_n\}$, und $j \in F_n=\{j \in \mathbb{Z} : -\pi < \omega_j \leq \pi \}$.

Die Funktion *periodogram* implementiert das Periodogramm und gibt einen numerischen Vektor zurück, welcher die Ausprägungen des Periodogramms an den Stellen $\omega_j$ ($j \in F_n$) enthält.
$$
I(\omega_j)=n^{-1} \Bigg| \sum \limits_{t=1}^{n}x_{t}e^{-it\omega_j} \Bigg| ^2
$$

Folgender Code beschreibt die Anwendung der Funktion in R:
```{r}
x <-  arma_sim(phi = c(1,-0.6), n = 1000, burnin = 500)
periodo <- periodogram(x)

ggplot() +
  geom_point(mapping = aes(1:500,periodo[501:1000])) + 
  geom_line(mapping = aes(1:500,periodo[501:1000])) + 
  labs(title="Periodogramm", x="Frequenz", y = "f(w)") 
```
Da für die Fourier-Frequenzen gilt $I(-\omega_j) = I(\omega_j)$, bietet es sich an nur eine Seite des Periodogramms in dern Graphen aufzunehemen.

Wenn eine Zeitreihe glatt (bzw. verwackelt) erscheint, dann werden die Werte des Periodogramms für niedrige (bzw. hohe) Frequenzen im Verhältnis zu seinen anderen Werten groß sein, und man sagt, dass der Datensatz einen Überschuss an niedrigen (bzw. hohen) Frequenz aufweist.Bei einer rein zufälligen Serie sollten alle Sinus- und Cosinuskurven von gleicher Bedeutung sein, und daher wird das Periodogramm zufällig um eine Konstante variieren.
Sollte eine Zeitreihe ein starkes sinusartiges Signal für eine Frequenz aufweise, dann wird das Periodogramm eine Spitze bei dieser Frequenz aufweisen.Falls die Zeitreihe ein starkes nicht-sinusbasiertes Signal für eine Frequenz aufweißt, wird das Periodogramm eine Spitze in dieser Frequenz und den Vielfachen aufweißen.


## Literatur
Brockwell, Peter J., Richard A. Davis, and Matthew V. Calder. Introduction to time series and forecasting. Vol. 2. New York: Springer, 2002.
=======
```{r}
set.seed(1234)
ma_obj <- arma_sim(theta = c(0.6,-0.2), n = 500, burnin = 2000)
innov <- innovation(ma_obj)
print(innov[[1]][1:10,1:10])
print(innov[[2]][1:10])
```
Man sieht das die $\theta_{.,1}$ nahe an 0.6 sind und die $\thetas_{.,2}$ nahe an -0,2 sind. Die restlichen $\theta's$ sind im Vergleich dazu relativ klein. In der Theorie sollten diese gleich Null sein. Dies schafft diese Implemantion nicht.
Die Vohersage wird dann durch die *innovation_prediction* getätigt, wobei hier eine Ein-Schritt Vorhersage getätigt wird.
```{r}
innovation_prediction(ma_obj)
```
## Innovation Prediction
Diese Funktion benutzt den Innovation Algorithmus um die Vorhersage für das nächsten (bzw. für das n-te) Wert zu bestimmen. Nach Brockwell sind dies die Algorithmen dazu:
$$ P_0=0. $$
$$  P_{n}=\hat{X}_{n+1}=\sum_{j=1}^{n}\theta_{n,j}(X_{n+1-j}-\hat{X}_{n+1-j}. . $$

bzw. zur Berechnung von $P_{n+h-1}$:
$$ P_{n+h-1}=\hat{X}_{n+h}=\sum_{j=h}^{n+h-1}\theta_{n+h-1,j}(X_{n+h-j}-\hat{X}_{n+h-j}). $$

Da aber für die Vorhersage des n-te Wertes $\theta$ bis zu $\theta_{n+h-1,n+h-1}$ berechnet werden muss, werden die ersten n Werte nur zur Berechnung der $\theta's$ benutzt werden.

Die Funktion hat als neben der Zeitreihe *ts*, noch die optionalen Eingabenwerte *steps* und *lag.max*. Wobei steps (Standardwert = 1) angibt welches steps-te Element man vorhersagen will und *lag.max* (Standardwert: length(ts)-steps), wie viele Elemente der Zeitreihe benutzt werden, wobei die ersten step Schritte immer benötigt werden um die $\theta's$ des letzten Schritt zu berechnen.
Folgender Beispiel Code zeigt die Benutzung:
```{r}
innovation_prediction(ma_obj)
innovation_prediction(ma_obj,steps=2)