---
title: "Simulationsstudie"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulationsstudie}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In dieser kurzen Simulationsstudie sollen die Möglichkeiten des Paketes weiter veranschaulicht werden. Dazu wird zuerst wieder das Paket *TimeSeries* geladen.

```{r setup}
library(TimeSeries)
library(tibble)
library(ggplot2)
```

## Theoretische ACF eines AR(1)-Prozesses

In diesem Teil soll die Funktion *acf* getestet werden. Dazu wird ein AR(1)-Prozess mithilfe der Funktion *arma_sim* simuliert. Für diesen Prozess ist es leicht möglich die wahre theoretische Autokovarianz-Funktion zu berechnen.
Das Modell hat die folgende Form, wobei $\epsilon$ "white noise" ist:

$$
X_t=\phi X_{t-1}+\epsilon_t
$$
Die Varianz $\gamma_0$ berechnet sich folgendermaßen:

$$
\gamma(0)=Var(X_t)=Var(\phi X_{t-1}+\epsilon_t)=Var(\phi X_{t-1})+\sigma_{\epsilon}^2=\phi^2 Var(X_{t-1})+\sigma_{\epsilon}^2= \frac{\sigma_{\epsilon}^2}{1-\phi^2}
$$
Nun sind auch die weitern Autokovarianzen leicht bestimmbar:

$$
\gamma(1)=Cov(X_{t+1},X_t)=Cov(\phi X_t+\epsilon_t,X_t)=Cov(\phi X_t,X_t)+Cov(\epsilon_{t+1},X_t)=\phi Cov(X_t,X_t)+0=\phi \gamma(0)
$$
Nun wird die theoretische ACF für eine AR(1)-Prozess mit $\phi=0.8$ und $n=100$ berechnet.
Später wird die Standardnormalverteilung für den Noise verwendet. Somit gilt $\sigma_{\epsilon}^2=1$.
```{r fig1, fig.width = 7, fig.asp = .3}
gamma_0 <- 1/(1-0.8^2)

true_acf <- numeric(50)
for(i in 0:49){
        gamma_i <- gamma_0*0.8^i
        true_acf[i+1] <- gamma_i
}

true_tbl <- tibble(ACF=true_acf, Lag=seq_along(true_acf))

true_acf_plot <- ggplot(true_tbl, aes(x=Lag, y=ACF)) +
                geom_bar(stat="identity") + 
                ggtitle("Theoretical ACF: AR(1)")
true_acf_plot
```

Nun werden Daten mit den oben beschriebenen Eigenschaften simuliert und die ACFs geschätzt. Es werden Zeitreihen unterschiedlicher Länge erzeugt um zu sehen, ob sich die geschätzten ACFs mit größerer Stichprobengröße dem theoretischen ACF annähern. Es werden lange "burn-in"-Perioden gewählt, damit die Zeitreihe kaum von den zufälligen Startwerten abhängt. Dazu wird eine kleine Funktion erstellt, welche die simulierten ACFs mit dem theoretischen ACF

```{r fig2, fig.width = 7, fig.asp = .3}
set.seed(1234)
ar_obj_50 <- arma_sim(phi = 0.8, n=50, burnin=1000)
ar_obj_100 <- arma_sim(phi = 0.8, n=100, burnin=1000)
ar_obj_200 <- arma_sim(phi = 0.8, n=200, burnin=1000)
ar_obj_500 <- arma_sim(phi = 0.8, n=500, burnin=1000)
ar_obj_1000 <- arma_sim(phi = 0.8, n=1000, burnin=1000)
ar_obj_5000 <- arma_sim(phi = 0.8, n=5000, burnin=1000)

acf_plot <- function(ar, ...){
        ar_acf <- acf(ar)[1:50]
        acf_plot <- ggplot(tibble(ACF=ar_acf, Lag=seq_along(ar_acf)), aes(x=Lag, y=ACF)) +
                geom_bar(stat="identity") + 
                ggtitle(...)
acf_plot
}

acf_plot(ar_obj_50, "50 obs") +
        geom_bar(data = true_tbl, mapping = aes(x=Lag, y=ACF))
acf_plot(ar_obj_100, "100 obs")
acf_plot(ar_obj_200, "200 obs")
acf_plot(ar_obj_500, "500 obs")
acf_plot(ar_obj_1000, "1000 obs")
acf_plot(ar_obj_5000, "5000 obs")

```

